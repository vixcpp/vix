
# -------- Release Makefile (robuste et reprenable) --------
#
# Compatible with strict GitHub repository rules:
# - main is protected: changes must go through a Pull Request
# - main must not contain merge commits (use SQUASH or REBASE in GitHub)
#
# Workflow:
#   make release VERSION=vX.Y.Z
#   -> prepares release on dev (commit + push) + prints PR instructions
#   -> open PR dev -> main and merge using SQUASH/REBASE (no merge commit)
#   make tag VERSION=vX.Y.Z
#   -> creates annotated tag on main after PR merge (recommended)
#
# ----------------------------------------------------------

VERSION ?= v0.1.0
BRANCH_DEV = dev
BRANCH_MAIN = main

# If VERSION doesn't start with "v", prefix it.
# Examples:
#   VERSION=1.9.0  -> TAG=v1.9.0
#   VERSION=v1.9.0 -> TAG=v1.9.0
TAG := $(if $(filter v%,$(VERSION)),$(VERSION),v$(VERSION))

.PHONY: help release release-fast commit push tag resume-tag pr-instructions         test changelog submodules submodules-remote gh-release         assert-dev assert-main assert-clean

help:
	@echo "Available commands:"
	@echo "  make release VERSION=vX.Y.Z       - Prepare release on $(BRANCH_DEV): changelog + commit + push + PR instructions"
	@echo "  make release-fast VERSION=vX.Y.Z  - Same as release but without changelog step"
	@echo "  make commit                       - Commit on $(BRANCH_DEV) (if there are changes)"
	@echo "  make push                         - Push $(BRANCH_DEV)"
	@echo "  make tag VERSION=vX.Y.Z           - Create and push annotated tag on $(BRANCH_MAIN) (run after PR merge)"
	@echo "  make resume-tag VERSION=vX.Y.Z    - Only (re)push the tag step"
	@echo "  make gh-release VERSION=vX.Y.Z    - Create GitHub release from TAG (needs 'gh')"
	@echo "  make submodules                   - Sync/init submodules"
	@echo "  make test                         - Run ctest from ./build"
	@echo "Current VERSION=$(VERSION) -> TAG=$(TAG)"

# --- Guards ---
assert-dev:
	@if [ "$$(git rev-parse --abbrev-ref HEAD)" != "$(BRANCH_DEV)" ]; then 		echo "‚ÑπÔ∏è  Switching to $(BRANCH_DEV)"; 		git checkout $(BRANCH_DEV); 	fi

assert-main:
	@if [ "$$(git rev-parse --abbrev-ref HEAD)" != "$(BRANCH_MAIN)" ]; then 		echo "‚ÑπÔ∏è  Switching to $(BRANCH_MAIN)"; 		git checkout $(BRANCH_MAIN); 	fi

assert-clean:
	@if [ -n "$$(git status --porcelain)" ]; then 		echo "‚ùå Working tree not clean. Commit or stash before continuing."; 		exit 1; 	fi

# --- Steps ---

commit: assert-dev
	@if [ -n "$$(git status --porcelain)" ]; then 		echo "üìù Committing changes on $(BRANCH_DEV)..."; 		git add .; 		git commit -m "chore(release): prepare $(TAG)"; 	else 		echo "‚úÖ Nothing to commit on $(BRANCH_DEV)."; 	fi

push: assert-dev
	@echo "‚¨ÜÔ∏è  Pushing $(BRANCH_DEV)..."
	@for i in 1 2 3; do 		git push origin $(BRANCH_DEV) && s=0 && break || s=$$?; 		echo "‚ö†Ô∏è  Push $(BRANCH_DEV) failed (try $$i/3). Retrying in 2s..."; 		sleep 2; 	done; exit $$s

# Create and push annotated tag on main AFTER the PR is merged.
tag: assert-main assert-clean
	@if git rev-parse --verify --quiet $(TAG) >/dev/null; then 		echo "‚ÑπÔ∏è  Local tag $(TAG) already exists."; 	else 		echo "üè∑Ô∏è  Creating annotated tag $(TAG) on $(BRANCH_MAIN)..."; 		git tag -a $(TAG) -m "Release version $(TAG)"; 	fi; 	if git ls-remote --tags origin $(TAG) | grep -q "$(TAG)"; then 		echo "‚úÖ Remote already has tag $(TAG). Nothing to push."; 	else 		echo "‚¨ÜÔ∏è  Pushing tag $(TAG) to origin..."; 		for i in 1 2 3; do 			git push origin $(TAG) && s=0 && break || s=$$?; 			echo "‚ö†Ô∏è  Push tag failed (try $$i/3). Retrying in 2s..."; 			sleep 2; 		done; exit $$s; 	fi

resume-tag:
	@$(MAKE) tag VERSION=$(VERSION)

release:
	@$(MAKE) changelog
	@$(MAKE) commit VERSION=$(VERSION)
	@$(MAKE) push
	@$(MAKE) pr-instructions VERSION=$(VERSION)
	@echo "‚úÖ Release $(TAG) prepared on $(BRANCH_DEV)."
	@echo "‚ÑπÔ∏è  After merging the PR (SQUASH/REBASE), run:"
	@echo "    make tag VERSION=$(VERSION)"

# Same as release but without changelog step (useful if you already updated it).
release-fast:
	@$(MAKE) commit VERSION=$(VERSION)
	@$(MAKE) push
	@$(MAKE) pr-instructions VERSION=$(VERSION)
	@echo "‚úÖ Release $(TAG) prepared on $(BRANCH_DEV) (fast)."
	@echo "‚ÑπÔ∏è  After merging the PR (SQUASH/REBASE), run:"
	@echo "    make tag VERSION=$(VERSION)"

pr-instructions:
	@echo ""
	@echo "Next step (required by repo rules):"
	@echo "  1) Open a Pull Request: $(BRANCH_DEV) -> $(BRANCH_MAIN)"
	@echo "  2) Merge using SQUASH (recommended) or REBASE."
	@echo "     Do NOT create a merge commit."
	@echo "  3) After merge, tag on main:"
	@echo "     make tag VERSION=$(VERSION)"
	@echo "  4) Optionally publish a GitHub Release from tag $(TAG)."
	@echo ""

gh-release:
	@if ! command -v gh >/dev/null 2>&1; then 		echo "‚ùå 'gh' CLI not found. Install GitHub CLI to use this target."; 		exit 1; 	fi
	@echo "üì¶ Creating GitHub Release for $(TAG)..."
	@gh release create $(TAG) --title "$(TAG)" --notes-file CHANGELOG.md || 		{ echo "‚ö†Ô∏è  'gh release' failed. Maybe it already exists?"; exit 0; }

test:
	@cd build && ctest --output-on-failure

changelog:
	@bash scripts/update_changelog.sh

submodules:
	@./scripts/submodules-sync.sh

submodules-remote:
	@./scripts/submodules-sync.sh remote
# ----------------------------------------------------------

