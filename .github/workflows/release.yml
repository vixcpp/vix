name: release

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Optional tag to build/release (e.g. v1.23.0). If empty, uses the current ref."
        required: false
        default: ""

permissions:
  contents: write

jobs:
  build-release:
    name: build (${{ matrix.vixos }} / ${{ matrix.arch }})
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-22.04
            vixos: linux
            arch: x86_64

          - os: ubuntu-22.04-arm
            vixos: linux
            arch: aarch64

          - os: macos-15-intel
            vixos: macos
            arch: x86_64

          - os: macos-14
            vixos: macos
            arch: aarch64

          - os: windows-2022
            vixos: windows
            arch: x86_64

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0

      # If user provided a tag via workflow_dispatch, checkout that tag explicitly
      - name: Checkout tag (manual input)
        if: ${{ github.event.inputs.tag != '' }}
        shell: bash
        run: |
          set -euxo pipefail
          git fetch --tags --force
          git checkout "tags/${{ github.event.inputs.tag }}"

      - name: Setup CMake
        uses: lukka/get-cmake@latest

      # -------------------------
      # Linux deps (native only)
      # -------------------------
      - name: Install deps (Linux)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            pkg-config ninja-build ca-certificates \
            libssl-dev zlib1g-dev libsqlite3-dev libbrotli-dev

      # -------------------------
      # Linux aarch64 toolchain + arm64 dev libs (cross)
      # -------------------------
      - name: Setup Linux aarch64 toolchain
        if: runner.os == 'Linux' && matrix.arch == 'aarch64'
        shell: bash
        run: |
          set -euxo pipefail

          sudo dpkg --add-architecture arm64
          sudo apt-get update

          sudo apt-get install -y --no-install-recommends \
            gcc-aarch64-linux-gnu g++-aarch64-linux-gnu \
            pkg-config ninja-build ca-certificates \
            libssl-dev:arm64 \
            zlib1g-dev:arm64 \
            libsqlite3-dev:arm64 \
            libbrotli-dev:arm64

          cat > toolchain-aarch64.cmake <<'EOF'
          set(CMAKE_SYSTEM_NAME Linux)
          set(CMAKE_SYSTEM_PROCESSOR aarch64)

          set(CMAKE_C_COMPILER   aarch64-linux-gnu-gcc)
          set(CMAKE_CXX_COMPILER aarch64-linux-gnu-g++)

          set(CMAKE_FIND_ROOT_PATH
            /usr/aarch64-linux-gnu
            /usr/lib/aarch64-linux-gnu
            /usr/include/aarch64-linux-gnu
            /usr
          )

          set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
          set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
          set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
          set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
          EOF

      # -------------------------
      # macOS deps
      # -------------------------
      - name: Install deps (macOS)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euxo pipefail
          brew update
          brew install pkg-config openssl@3 || true

      # -------------------------
      # Windows deps
      # -------------------------
      - name: Install deps (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          choco install openssl -y

      # -------------------------
      # Configure (Unix)
      # -------------------------
      - name: Configure (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          set -euxo pipefail

          CMAKE_ARGS=(
            -S . -B build -G Ninja
            -DCMAKE_BUILD_TYPE=Release
            -DVIX_ENABLE_INSTALL=OFF
            -DVIX_DB_USE_MYSQL=OFF
            -DVIX_CORE_WITH_MYSQL=OFF
            -DVIX_ENABLE_HTTP_COMPRESSION=OFF
            --log-level=VERBOSE
            --debug-output
          )

          if [ "${{ runner.os }}" = "Linux" ] && [ "${{ matrix.arch }}" = "aarch64" ]; then
            CMAKE_ARGS+=(
              -DCMAKE_TOOLCHAIN_FILE="${GITHUB_WORKSPACE}/toolchain-aarch64.cmake"
              --debug-find
            )
          fi

          if [ "${{ runner.os }}" = "macOS" ]; then
            if command -v brew >/dev/null 2>&1; then
              BREW_SSL="$(brew --prefix openssl@3 2>/dev/null || true)"
              if [ -n "$BREW_SSL" ] && [ -d "$BREW_SSL" ]; then
                CMAKE_ARGS+=(-DOPENSSL_ROOT_DIR="$BREW_SSL")
              fi
            fi
          fi

          cmake "${CMAKE_ARGS[@]}" 2>&1 | tee cmake_output.log

      - name: Dump CMake logs (Unix)
        if: failure() && runner.os != 'Windows'
        shell: bash
        run: |
          set +e
          echo "=== build/ dir ==="
          ls -la build || true
          echo
          echo "=== CMakeError.log (tail) ==="
          test -f build/CMakeFiles/CMakeError.log && tail -n 250 build/CMakeFiles/CMakeError.log || echo "missing"
          echo
          echo "=== CMakeOutput.log (tail) ==="
          test -f build/CMakeFiles/CMakeOutput.log && tail -n 250 build/CMakeFiles/CMakeOutput.log || echo "missing"
          echo
          echo "=== CMakeConfigureLog.yaml (tail) ==="
          test -f build/CMakeFiles/CMakeConfigureLog.yaml && tail -n 250 build/CMakeFiles/CMakeConfigureLog.yaml || echo "missing"
          echo
          echo "=== cmake_output.log (tail) ==="
          test -f cmake_output.log && tail -n 200 cmake_output.log || echo "missing"

      # Upload logs into a UNIQUE folder to avoid extraction collisions
      - name: Collect logs (Unix)
        if: always() && runner.os != 'Windows'
        shell: bash
        run: |
          set -euxo pipefail
          OUT="logs/${{ matrix.vixos }}-${{ matrix.arch }}"
          mkdir -p "$OUT"
          echo "no logs captured (step failed before logs were generated)" > "$OUT/_no_logs.txt"
          test -f cmake_output.log && cp -f cmake_output.log "$OUT/" || true
          test -f build_output.log && cp -f build_output.log "$OUT/" || true
          test -f build/CMakeCache.txt && cp -f build/CMakeCache.txt "$OUT/" || true
          test -f build/CMakeFiles/CMakeError.log && cp -f build/CMakeFiles/CMakeError.log "$OUT/" || true
          test -f build/CMakeFiles/CMakeOutput.log && cp -f build/CMakeFiles/CMakeOutput.log "$OUT/" || true
          test -f build/CMakeFiles/CMakeConfigureLog.yaml && cp -f build/CMakeFiles/CMakeConfigureLog.yaml "$OUT/" || true
          find logs -type f -maxdepth 3 -print || true

      - name: Collect logs (Windows)
        if: always() && runner.os == 'Windows'
        shell: pwsh
        run: |
          $out = "logs/${{ matrix.vixos }}-${{ matrix.arch }}"
          New-Item -ItemType Directory -Force -Path $out | Out-Null

          if (Test-Path "cmake_output.log") {
            Copy-Item "cmake_output.log" $out -Force
          }

          if (Test-Path "build\CMakeCache.txt") {
            Copy-Item "build\CMakeCache.txt" $out -Force
          }

          if (Test-Path "build\CMakeFiles\CMakeError.log") {
            Copy-Item "build\CMakeFiles\CMakeError.log" $out -Force
          }

          if (Test-Path "build\CMakeFiles\CMakeOutput.log") {
            Copy-Item "build\CMakeFiles\CMakeOutput.log" $out -Force
          }

          if (Test-Path "build\CMakeFiles\CMakeConfigureLog.yaml") {
            Copy-Item "build\CMakeFiles\CMakeConfigureLog.yaml" $out -Force
          }

          if (-not (Get-ChildItem -File $out -ErrorAction SilentlyContinue)) {
            "no logs captured (step failed before logs were generated)" | Out-File (Join-Path $out "_no_logs.txt") -Encoding utf8
          }

          if (Test-Path "build_output.log") { Copy-Item "build_output.log" $out -Force }

          if (Test-Path "build") {
            Compress-Archive -Path "build\*" -DestinationPath "$out\build.zip" -Force
          }

          Get-ChildItem -Recurse -Depth 3 logs | ForEach-Object { $_.FullName }

      - name: Build (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          set -euxo pipefail
          : > build_output.log
          cmake --build build -j 2>&1 | tee -a build_output.log

      - name: Collect logs (post-build) (Unix)
        if: always() && runner.os != 'Windows'
        shell: bash
        run: |
          set -euxo pipefail
          OUT="logs/${{ matrix.vixos }}-${{ matrix.arch }}"
          mkdir -p "$OUT"
          test -f build_output.log && cp -f build_output.log "$OUT/" || true
          find logs -type f -maxdepth 3 -print || true

      - name: Upload logs (configure + build)
        if: always() && runner.os != 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: logs-${{ matrix.vixos }}-${{ matrix.arch }}
          path: logs/${{ matrix.vixos }}-${{ matrix.arch }}/*
          if-no-files-found: warn

      # -------------------------
      # Configure + Build (Windows)
      # -------------------------
      - name: Configure (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          "" | Out-File -FilePath cmake_output.log -Encoding utf8

          $openssl = (Get-ChildItem "C:\Program Files" -Directory -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -like "OpenSSL-*" } | Select-Object -First 1).FullName
          if (-not $openssl) { $openssl = "C:\Program Files\OpenSSL-Win64" }
          Write-Host "OPENSSL_ROOT_DIR=$openssl"

          cmake -S . -B build -A x64 `
            -DVIX_ENABLE_INSTALL=OFF `
            -DVIX_DB_USE_MYSQL=OFF `
            -DVIX_CORE_WITH_MYSQL=OFF `
            -DVIX_ENABLE_HTTP_COMPRESSION=OFF `
            -DOPENSSL_ROOT_DIR="$openssl" 2>&1 | Tee-Object -FilePath cmake_output.log -Append

          if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }

      - name: Build (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          "" | Out-File -FilePath build_output.log -Encoding utf8
          cmake --build build --config Release 2>&1 | Tee-Object -FilePath build_output.log -Append
          if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }

      - name: Collect logs (post-build) (Windows)
        if: always() && runner.os == 'Windows'
        shell: pwsh
        run: |
          $out = "logs/${{ matrix.vixos }}-${{ matrix.arch }}"
          New-Item -ItemType Directory -Force -Path $out | Out-Null
          if (Test-Path "cmake_output.log") { Copy-Item "cmake_output.log" $out -Force }
          if (Test-Path "build_output.log") { Copy-Item "build_output.log" $out -Force }

      - name: Upload logs (configure + build)
        if: always() && runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: logs-${{ matrix.vixos }}-${{ matrix.arch }}
          path: logs/${{ matrix.vixos }}-${{ matrix.arch }}/*
          if-no-files-found: warn

      # -------------------------
      # Package artifact
      # -------------------------
      - name: Package (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          set -euxo pipefail

          BIN=""
          for p in "build/vix" "build/bin/vix" "build/Release/vix"; do
            if [ -f "$p" ]; then BIN="$p"; break; fi
          done

          if [ -z "$BIN" ]; then
            echo "Expected vix binary not found. Listing build/ ..." >&2
            ls -la build || true
            find build -maxdepth 5 -type f -name vix -print || true
            exit 1
          fi

          mkdir -p dist
          cp "$BIN" dist/vix
          chmod +x dist/vix

          ASSET="vix-${{ matrix.vixos }}-${{ matrix.arch }}.tar.gz"
          tar -C dist -czf "dist/$ASSET" vix
          rm -f dist/vix

      - name: Package (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $candidates = @(
            "build\vix.exe",
            "build\Release\vix.exe",
            "build\bin\vix.exe",
            "build\Release\bin\vix.exe"
          )

          $bin = $null
          foreach ($p in $candidates) {
            if (Test-Path $p) { $bin = $p; break }
          }

          if (!$bin) {
            Write-Host "Expected vix.exe not found in build outputs"
            if (Test-Path "build") { Get-ChildItem -Recurse build | Select-Object FullName }
            exit 1
          }

          New-Item -ItemType Directory -Force -Path dist | Out-Null
          Copy-Item $bin dist\vix.exe

          $asset = "vix-windows-${{ matrix.arch }}.zip"
          Compress-Archive -Path dist\vix.exe -DestinationPath "dist\$asset" -Force
          Remove-Item dist\vix.exe -Force

      - name: Upload dist
        uses: actions/upload-artifact@v4
        with:
          name: dist-${{ matrix.vixos }}-${{ matrix.arch }}
          path: dist/*

  publish:
    name: publish (github release)
    needs: build-release
    runs-on: ubuntu-22.04
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist-all

      - name: Flatten
        shell: bash
        run: |
          set -euxo pipefail
          mkdir -p dist
          find dist-all -type f -maxdepth 4 -print0 | while IFS= read -r -d '' f; do
            base="$(basename "$f")"
            if [ -f "dist/$base" ]; then
              echo "Collision while flattening: $base" >&2
              exit 1
            fi
            cp -f "$f" "dist/$base"
          done
          ls -la dist

      - name: Create GitHub Release + upload
        uses: softprops/action-gh-release@v2
        with:
          files: dist/*
